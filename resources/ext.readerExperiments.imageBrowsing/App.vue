<template>
	<div class="ib-app">
		<carousel
			v-if="contentImages.length > 2"
			ref="carouselRef"
			:images="contentImages"
			@carousel-item-click="onCarouselItemClick"
		>
		</carousel>

		<teleport :to="teleportTarget">
			<overlay
				v-if="activeImage"
				:images="contentImages"
				:active-image="activeImage"
				@overlay-close="onOverlayClose"
				@vtoc-item-click="onVTOCItemClick"
				@vtoc-view-in-article="onVTOCViewInArticle"
			></overlay>
		</teleport>
	</div>
</template>

<script>
const { defineComponent, ref, inject, useTemplateRef } = require( 'vue' );
const router = require( 'mediawiki.router' );
const useContentImages = require( './composables/useContentImages.js' );
const useExternalImages = require( './composables/useExternalImages.js' );
const useEntityId = require( './composables/useEntityId.js' );
const Carousel = require( './components/Carousel.vue' );
const Overlay = require( './components/Overlay.vue' );

// @vue/component
module.exports = exports = defineComponent( {
	name: 'ImageBrowsing',
	components: {
		Carousel,
		Overlay
	},
	setup() {
		const contentImages = ref( null );
		const activeImage = ref( null );

		const teleportTarget = inject( 'CdxTeleportTarget' );

		// Reference to the Carousel component for focus management
		const carouselRef = useTemplateRef( 'carouselRef' );

		// Extract thumbnail image (as an array of ImageData objects)
		// from the content of the underlying article page.
		const contentElement = document.getElementById( 'content' );
		if ( contentElement ) {
			contentImages.value = useContentImages( contentElement );
		}

		// Client-side routing config
		// Set up route for overlay images
		const routePrefix = '/imagebrowsing/';
		const routePrefixRegExp = /^\/imagebrowsing\/(.+)$/;
		// Add a dynamic route that matches `/imagebrowsing/*` to support per-image navigation
		router.addRoute(
			routePrefixRegExp,
			async ( prefixedDbFileTitle ) => {
				const uriDecoded = decodeURIComponent( prefixedDbFileTitle );

				// Attempt to locate the image in the content images first
				let image = contentImages.value.find(
					( imageData ) => imageData.title.getPrefixedDb() === uriDecoded
				);

				// If we could not find the image, it may have been an image
				// from an external source
				if ( !image ) {
					// Unlike for local images, where we're using the same ref
					// that is passed throughout the app to perform the lookup,
					// we're explicitly calling useExternalImages() both here
					// and in the component we'll be rendering them in.
					// I wish there was a clean way to pass around the same data,
					// but then it would have to be either immediately initialized
					// (as opposed to the lazy init we have now, based on users
					// either clicking to show these images, or requesting it via
					// a shared/history URL), or we would have to proxy the data
					// and always treat it as a Promise, which, while doable,
					// is still different from how we handle local images.
					// Anyway, useExternalImages() just caches its results, so
					// repeat calls from different places are not really an issue.
					const entityId = await useEntityId();
					const externalImages = entityId ?
						await useExternalImages( entityId, contentImages.value ) :
						[];
					image = externalImages.find(
						( imageData ) => imageData.title.getPrefixedDb() === uriDecoded
					);
				}

				if ( image ) {
					activeImage.value = image;
				} else {
					// Invalid images should not be a hard fail, since it is possible that
					// a completely valid url got shared, but the image has since been removed
					// from the page
					// eslint-disable-next-line no-console
					console.error( '[ImageBrowsing] Invalid navigation image; could not find:', prefixedDbFileTitle );
					activeImage.value = null;
				}
			},
			() => {
				// This teardown handler is called when transitioning from a matching route
				// (i.e. one with /imagebrowsing/ + filename, where we want to show the image)
				// to one that doesn't (anything else - like going back to no hash (closing the
				// image, or through browser history)) where we don't want an image
				activeImage.value = null;
			}
		);
		// Check the current route & immediately navigate to the relevant imagine
		// in case the user came from a shared/history URL
		router.checkRoute();
		// Helper function to simplify navigation to images, just so that those event
		// handlers don't have to worry about constructing the appropriate route path
		function navigateTo( image ) {
			let path;

			if ( !image ) {
				// explicit navigation out of this app
				path = '';
			} else if ( image.title ) {
				// navigate to image
				path = routePrefix + image.title.getPrefixedDb();
			} else {
				// Invalid input to this function would be generated by code & should fail hard
				// eslint-disable-next-line no-console
				console.error( '[ImageBrowsing] Invalid navigation input; expected ImageData but received:', image );
				throw new Error( '[ImageBrowsing] Invalid navigation input' );
			}

			router.navigate( path );
		}

		//
		// Carousel's event handlers.
		//

		/**
		 * @param {import('./types').ImageData} image
		 */
		function onCarouselItemClick( image ) {
			// When a carousel image is clicked, set it as the active image
			// and show the overlay part of the UI.
			activeImage.value = image;
			navigateTo( image );
		}

		//
		// Detail view's event handlers.
		//

		function onOverlayClose() {
			navigateTo( null );

			// Return focus to the selected carousel item when the overlay closes
			if ( carouselRef.value && carouselRef.value.focusActiveItem ) {
				carouselRef.value.focusActiveItem();
			}
		}

		//
		// Visual table of contents' (VTOC) event handlers.
		//

		function onVTOCItemClick( image ) {
			activeImage.value = image;
		}

		/**
		 * @param {import('./types').ImageData} image
		 */
		function onVTOCViewInArticle( image ) {
			activeImage.value = null;

			// Scroll the main page view to the image in context.
			// Do not use image.thumb, as that may be a lazy-load placeholder
			// span which has already been replaced; use the container.
			if ( image.container ) {
				// In mobile mode, sections may be collapsed.
				// Toggle the section if necessary.
				const section = image.container.closest( '.collapsible-block-js' );
				if ( section && section.classList && !section.classList.contains( 'open-block' ) ) {
					const headingWrapper = section.previousSibling;
					if ( headingWrapper ) {
						headingWrapper.click();
					}
				}
				image.container.scrollIntoView( {
					behavior: 'smooth'
				} );
			}
		}

		return {
			contentImages,
			activeImage,
			teleportTarget,
			carouselRef,
			onCarouselItemClick,
			onOverlayClose,
			onVTOCItemClick,
			onVTOCViewInArticle
		};
	}
} );
</script>

<style lang="less">
// @hack why is this necessary to get the overlay to show up properly? Fix and remove
#mw-teleport-target {
	top: 0;
	left: 0;
}
</style>
